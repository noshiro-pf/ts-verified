/**
 * Creates a memoized version of a function.
 * The memoized function caches the results of function calls and returns the cached result
 * when the same inputs occur again.
 *
 * @template A The type of the arguments array for the function `fn`.
 * @template R The return type of the function `fn`.
 * @template K The type of the cache key generated by `argsToCacheKey`. Must be a valid Map key type.
 * @param fn The function to memoize.
 * @param argsToCacheKey A function that converts the arguments of `fn` into a cache key.
 *                       The cache key should uniquely identify the set of arguments.
 *                       For object arguments, use primitive values (string, number) as keys.
 * @returns A new function that is a memoized version of `fn`.
 * @example
 * ```typescript
 * // Simple memoization for expensive calculation
 * const expensiveCalculation = (n: number): number => {
 *   console.log(`Computing for ${n}`);
 *   return n * n * n; // Expensive operation
 * };
 *
 * const memoized = memoizeFunction(
 *   expensiveCalculation,
 *   (n) => n // Use the number itself as cache key
 * );
 *
 * memoized(5); // Logs "Computing for 5", returns 125
 * memoized(5); // Returns 125 immediately (cached)
 * memoized(3); // Logs "Computing for 3", returns 27
 *
 * // Multi-argument function with string cache key
 * const multiply = (a: number, b: number): number => a * b;
 * const memoizedMultiply = memoizeFunction(
 *   multiply,
 *   (a, b) => `${a},${b}` // String concatenation as cache key
 * );
 *
 * // Complex cache key generation
 * const processUser = (user: { id: number; name: string }): string =>
 *   `User ${user.name} (${user.id})`;
 *
 * const memoizedProcessUser = memoizeFunction(
 *   processUser,
 *   (user) => user.id // Use user ID as cache key
 * );
 * ```
 */
export const memoizeFunction = <
  const A extends readonly unknown[],
  R,
  K extends Primitive,
>(
  fn: (...args: A) => R,
  argsToCacheKey: (...args: A) => K,
): ((...args: A) => R) => {
  const mut_cache = new Map<K, R>();

  return (...args: A): R => {
    const key = argsToCacheKey(...args);

    if (mut_cache.has(key)) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return mut_cache.get(key)!;
    } else {
      const result = fn(...args);

      mut_cache.set(key, result);

      return result;
    }
  };
};
